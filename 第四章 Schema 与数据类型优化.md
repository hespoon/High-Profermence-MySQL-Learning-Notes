[TOC]

# 第四章 Schema 与数据类型优化

## 临时表

MySQL 临时表用于保存一些临时数据。临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。

* 外部临时表

  通过 `CREATE TEMORPARY TABLE` 创建的临时表称为外部临时表。这种临时表的命名可与非临时表相同。同名后，非临时表对当前回话不可见，直到临时表被删除。

* 内部临时表

  内部临时表是一种特殊的轻量级临时表，由 MySQL 自动创建，用来存储某些操作的中间结果，达到性能优化的目的。该表一般是 Memory 表。如果中间结果太大超出了 Memory 的限制，或者含有 BLOB 或 TEXT 字段，则临时表会转换为 MyISAM 表。

## 对象关系映射 Object Relation Mapping 简称 OMP

面向对象的开发方法是当今企业级应用开发环境中的主流方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现方式。业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多的关联和继承关系。因此，对象-关系映射系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。

## 实体-属性-值模型 Entity-attribute-value model EAV

> [Entity-attribute-value mode-wiki]([https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model](https://en.wikipedia.org/wiki/Entity–attribute–value_model))

EAV 模型是一种数据模型。主要用于以较高的空间利用率编码一种特殊实体，该实体在整体上包含很多属性，但是具体到某一个个体时，只有有限个的属性有值，其他的属性都为空。这种实体与数学上的稀疏矩阵很相似。

EAV 表通常是瘦长的。瘦表示表的列很少，长表示表的行很多。

EAV 表通常有三列
 - entity 表示被描述的实体，该列一般是关联到实体定义表的外键。
 - attribute 该列一般是关联到一个属性定义表的外键。该属性定义表用来定义该属性，表格可能包含如下几种列：属性ID、属性名、属性描述、数据类型和用于辅助输入验证的列，比如，最大字符串长度、正则表达式或这一个包含有效数据的集合。
 - value 该列存放属性的值

使用 EAV 模型的两个例子：医院的病历记录，超市的销售数据。

EAV 使用了行模型。行模型表示一个实体被记录在很多行而不是很多列中，每行通常有三列：entity、attribute 和 value。

## 范式

> [常见范式设计](https://www.zhihu.com/question/24696366)

* 依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，记作 $X \to Y$。
* 完全函数依赖：在一张表中，若 $X \to Y$，且对于 X 的任何真子集 $X'$，$X' \to Y$ 不成立，那么我们称 Y 完全依赖于 X，记作 $ X \stackrel{F}{\to}Y$。
* 部分函数依赖：Y 函数依赖于 X，同时 Y 不完全依赖于 X，则称 Y 部分依赖于 X，记作 $X\stackrel{P}{\to}Y$。
* 传递函数依赖：Z 函数依赖于 Y，且 Y 函数依赖于 X，且 Y 不包含于 X，且 X 不函数依赖于 Y，则称 Z 传递依赖于 X，记作 $X\stackrel{T}{\to}Z$。
* 码：设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都有完全函数依赖于 K，那么我们称 K 为候选码，简称为码。通常可以这样理解：假如 K 确定的情况下，该表除 K 之外的所有属性的值也就确定，那么 K 就是码。一张表中可以有超过一个码，通常选择其中的一个码作为主码。
* 主属性：包含在任何一个码中的属性为主属性
* 判断表格符合那一个范式步骤
  1. 找出表中的所有码
  2. 根据第一步的码，找出所有主属性
  3. 除去所有的主属性，剩下的都是非主属性
  4. 查看函数依赖

1. 第一范式

   所有属性都是不可分割的原子值。

   数据库表的每一列都是不可分割的原子数据项，不能是集合，数组，记录等非原子数据项。

2. 第二范式

   在第一范式的基础上，要求非主属性都要==完全==依赖于码。

3. 第三范式

   任何非主属性不依赖于其他非主属性。

   第三范式是在第二范式的基础上建立起来的，消除了非主属性对于码的传递函数依赖。

4. BC 范式

   在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。

## 选择数据类型的原则

1. 更小的通常更好

    更小的数据类型通常占用更少的存储空间，处理时需要的 CPU 周期更少。

   同时要确保没有低估需要存储的值的范围。在 schema 中的多个地方增加数据类型是一个代价很高的操作。

2. 简单就好

   简单的数据类型操作通常需要更少的 CPU 周期。

   使用 MySQL 内建的数据类型存储日期和时间，而不是使用字符串。

   使用整形存储 IP 地址。

3. 尽量避免 NULL

   可为 NULL 是列的默认属性。

   通常情况下最好指定 NOT NULL，除非真的需要存储 NULL 值。

   包含 NULL 的列，对 MySQL 来说更难优化。

   可为 NULL 的列使得索引、索引统计和值比较都更加复杂。

   但是，通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小。所以，在调优时，没有必要首先修改这种情况。但是，在设计表格时要尽量避免 NULL。

4. 第一步，确定适合的大类型：数字、字符串、时间等。然后确定具体类型。MySQL 为了兼容性支持很多基本数据类型的别名，例如 INTEGER、BOOL 以及 NUMERIC。这些别名不会影响性能。

## 整数类型

|   类型    | 位数  |
| :-------: | :---: |
|  TINYINT  | 8 位  |
| SMALLINT  | 16 位 |
| MEDIUMINT | 24 位 |
|    INT    | 32 位 |
|  BIGINT   | 64 位 |



可存储的值的范围：$-2^{(N-1)}\thicksim2^{(N-1)}-1$，N 为位数。

有可选的 UNSIGNED 属性，表示无符号整数。可存储的值的范围：$0 \thicksim 2^N-1$，N   为位数。

数据类型决定整数是如何存储的。而整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境中也是如此。一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算。

可以为整数类型指定宽度，例如 INT(11)。这对大多数应用没有意义，这不会改变值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来讲 INT(1) 与 INT(20) 没有区别。

## 实数类型

|  类型   |  位数  |
| :-----: | :----: |
|  FLOAT  | 32 位  |
| DOUBLE  | 64 位  |
| DECIMAL | 128 位 |

DECIMAL(a,b)

参数说明：a 指定小数点左边和右边可以存储的十进制数字的最大个数。b 指定小数点右边可以存储的十进制数字的最大个数。

DECIMAL 只是一种存储格式，在实际计算中，DECIMAL 会转换为 DOUBLE。

CUP 不支持 DECIMAL 的直接运算，DECIMAL 的运算要在服务器层实现。相对而言，CUP 原生支持的浮点数运算更快。

MySQL 使用 DOUBLE 作为内部浮点计算的类型。

推荐只指定数据类型，不指定精度。

尽量只在对小数进行精确计算时才使用 DECIMAL，例如财务数据。

在数据量比较大时，可以使用 BIGINT 代替 DECIMAL，只需要将 DECIMAL 乘以合适的倍数将其转换为整数即可。这样可以避免浮点数计算精度问题和 DECIMAL 计算代价大的问题。

## 字符串类型

MySQL 4.1 开始，每个字符串列可以自定义自己的字符集和排序规则，这些东西会很大程度上影响性能。

### VARCHAR 和 CHAR 类型

 这两个数据类型在磁盘和内存中的存储方式与存储引擎的具体实现有关。以下以 InnoDB 和 MyISAM 在磁盘上的存储为例。

* VARCHAR

  用于存储可变长的字符串。

  比定长类型节省空间，因为它仅使用必要的空间。

  例外：如果表使用 ROW_FORMAT = FIXED 创建，每一行都会使用定长储存，这会很浪费存储空间。

  VARCHAR 需要使用额外的字节记录字符串的长度，如果列的最大长度小于等于 255 字节，则使用 1 个字节记录，否则使用 2 字节。

  由于行是变长的，在 UPDATE 时可能使行变得比原来长，这会导致额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间存储，在这种情况下，不同的存储引擎的处理方式不同。InnoDB 会分裂页来使行可以放入页内，MyISAM 会将行拆分成不同的片段存储。

  适用 VARCHAR 的情况：

  1. 字符串列的最大长度比平均长度大很多
  2. 列的更新很少
  3. 使用了像 UTF-8 这样的复杂字符集，每个字符都使用不同的字节进行存储。

  MySQL 5.0 及以上在存储和检索时会保留末尾空格。

  InnoDB 会把过长的 VARCHAR 存储为 BLOB。

* CHAR

  CHAR 是定长的。MySQL 总是根据定义的字符串长度为 CHAR 分配足够的空间。

  存储时，MySQL 会删除所有的末尾空格。

  CHAR 值会根据需要使用空格进行填充以便进行比较。

  适用 CHAR 的情况：

  1. 很短的字符串。
  2. 所有值都接近同一长度的字符串。比如 MD5 值。
  3. 对于经常变更的数据，CHAR 比 VARCHAR 更有效率，因为不容易产生碎片。

填充和截取空格的行为在不同的存储引擎中都是一样的，因为这是在服务器层处理的。

### BINARY 和 VARBINARY

与 CHAR 和 VARCHAR 很像。

这两个数据类型存储的是二进制的字符串，即存储的是字节码而不是字符。

填充时使用 \0 而不是空格。

二进制比较比字符比较简单很多，也就快很多。

### 慷慨是不明智的 最好的策略是只分配真正需要的空间

### BLOB 和 TEXT 类型

用于存储很大的数据。

BLOB 存储二进制数据，没有字符集和排序规则。

TEXT 存储字符数据，有字符集和排序规则。

|    字符类型     |   二进制类型    |
| :-------------: | :-------------: |
|    TINYTEXT     |    TINYBLOB     |
| SMALLTEXT(TEXT) | SMALLBLOB(BLOB) |
|   MEDIUMTEXT    |   MEDIUMBLOB    |
|    LONGTEXT     |    LONGBLOB     |

InnoDB 在 BLOB 或 TEXT 太大时，使用专用的外部存储区域存储，在行内只存储一个指向外部存储区域的指针。

只对每列最前的 max_sort_lenght 字节做排序而不是对整个字符串。

不能将 BLOB 和 TEXT 全部长度的字符串进行索引，也不能使用这些索引消除排序。

### 使用枚举类型代替字符串类型

枚举列可以把一些不重复的字符串存储成一个预定义的集合。

MySQL 在存储枚举时非常紧凑。

MySQL 在内部会用整数代替字符串保存在表中，并存储“数字-字符串”的映射关系。

枚举字段按照内部存储的整数而不是定义的字符串进行排序。可以通过按照需要的顺序定义枚举列来绕过这个限制。也可以在查询中使用 FIELD() 函数显示的指定排序顺序，但这回导致 MySQL 无法利用索引消除排序。

枚举的缺点是，字符串列的合法值是固定的，想要增加或删除字符串必须使用 ALTER TABLE。

MySQL 把枚举保存为整数，所以必须通过查找才能找到对应的字符串，这会带来一些开销。

## 日期和时间类型

MySQL 能存储的最小时间粒度为秒。

MariaDB 支持微妙级别的时间类型。

大部分时间类型都没有替代品，因此没有什么是最佳选择的问题。

### DATETIME

可表示的时间范围为 1001 年到 9999 年，精度为秒。

它把日期存放在 YYYYMMDDHHMMSS 型的整数中，与时区无关，使用 8 个字节的存储空间。

TIMESTAMP

保存了从 1970 年 1 月 1 日午夜（格林尼治标准时间）以来的秒数。

与 UNIX 时间戳相同。

使用 4 个字节的存储空间。

只能表示 1970 年到 2038 年。

TIMESTAMP 显示的时间与时区有关。

TIMESTAMP 为 0 时在美国东部时区显示为 “1969-12-31 19:00:00”。

TIMESTAMP 的行为复杂，并且在不同的 MySQL 版本里会有变动，所以最好在修改 TIMESTAMP 列以后，使用 SHOW CREATE TABLE 命令检查输出。

默认情况下，在插入时没有指定第一个 TIMESTAMP 列的值，MySQL 会设置这个列的值为当前时间。

在插入一行记录时，MySQL 会默认更新第一个 TIMESTAMP 列的值。

TIMESTAMP 列的值默认为 NOT NULL。

推荐尽量使用 TIMESTAMP，因为它空间效率更高。

当存储比秒更小粒度的时间时，可以用 BIGINT 或者 DOUBLE，或者使用 MariaDB。

## 位数据类型

这些位类型，从技术上将都是字符串类型。

### BIT 

在 MySQL 5.0  之前，BIT 是 TINYINT 的同义词。但在 MySQL 5.0 之后，这是一个完全不同的独立数据类型。

可以使用 BIT 列在一列中存储一个或多个 true/false 值。

BIT(1) 存储 1 个位，以此类推，最大长度为 64 位。

BIT 的行为因存储引擎而异。

MyISAM 会打包存储所有的 BIT 列，所以 17 个单独的 BIT 列只需要 17 个位存储。假设没有可为 NULL 的列。

MySQL 把 BIT 当作字符串类型，而不是数字类型。

而在数字上下文的场景中检索时，结果是将位字符串转换成的数字。

应当谨慎使用 BIT 类型，因为它很迷惑。

使用 1 位存储一个 true/false 值，另一个方法是使用一个可为空的 CHAR(0) 列。

### SET

可以使用 SET 存储很多 true/false 值。

它的主要缺点是改变列的定义的代价较高，只能使用 ALTER TABLE。

一种代替 SET 的方法是使用一个整数包装一系列的位。

例如，可以把 8 个位包装到一个 TINYINT 中，并且按照位操作来使用。可以为每个位定义名称常量来简化这个工作。

优点是改变列的定义时不用 ALTER TABLE，缺点是，查询语句难写，且读起来很迷惑。

## 选择标识符

为标识列选择合适的数据类型很重要。

> 标识列
>
> 该列主要是为了给表中的每一条记录做一个独一无二的标记
>
> 类似于 Microsoft Access 中的 AutoNumber 或者 Oracle 中的 sequence
>
> 标识列与主键的区别是，标识列的值被 DBMS 自动管理，且一般不允许修改
>
> 大部分情况下，标识列和主键是同一列，但并不总是如此
>
> 标识列很重要，所以很多 RDBMS 都有自己的实现，并且都有自己的术语用于描述标识列

不仅要考虑存储类型，还要考虑 MySQL 对这种类型怎么执行计算和比较。

标识列可能在另外的表中当作外键使用。在相关连的表中最好使用相同的数据类型，因为这些列很可能在关联中使用。类型之间要精确匹配，包括 UNSIGNED 这样的属性。

InnoDB 存储引擎不能在数据类型不完全匹配的情况下创建外键，否则会有报错信息：“ERROR 1005 (HY000): Can’t create table”。

整数通常是标识列的最好选择。

最好避免使用 ENUM 、SET 和 字符串类型作为标识列。

MyISAM 默认对字符串使用压缩索引，这会导致查询慢很多。

存储 UUID 值时应当移除 “-” 符号。更好的做法是，使用 UNHEX() 将 UUID 值转换为一个 16 字节的数字，并存储在一个 BINARY(16) 的列中。

应当注意完全随机的字符串。

要当心自动生成的 schema。

## 特殊类型数据

低于秒精度的时间戳

IPv4 地址。IPv4 地址实际上是一个 32 位的无符号整数，所以应当使用无符号整数存储 IP。

## MySQL schema 设计中的陷阱

### 太多的列

MySQL 的存储引擎 API 工作时需要在存储引擎层和服务器层通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码为各个列。

将行缓冲解码的代价非常高。

MyISAM 的定长行结构与服务器层的行结构刚好匹配，不用解码。

MyISAM 的边长行结构和 InnoDB 的行结构总是需要解码。

解码的代价依赖于列的数量。

列非常多时，解码的代价就会很高。

### 太多的关联

EAV 设计模式是一个常见的糟糕设计模式。在 MySQL 下不能正确的工作。

MySQL 限制每个关联操作最多只能有 61 张表，但 EVA 数据库会有很多关联，有时会超过 61 张表。

表关联在 61 一下时，对 MySQL 也不是很友好。

单个查询最好在 12 张表以内做关联。

### 过度使用枚举

```SQL
CREATE TABLE ... (
	country ENUM('','0','1',...,'31')
)
```

这不是一个好设计。这种情况应该使用整数作为外键关联到字典表或者查找表来查找具体的值。

### 变相的枚举

ENUM 列允许在列中存储一组定义值中的单个值，SET 列允许在列中存储一组定义值中的一个或多个值。

尽可能避免使用 NULL，即使必须要存储一个事实上的 “NULL” 时，也不一定要使用 NULL。可以使用 0，某个特殊值，或者空字符串作为代替。但是，在某些特殊场景中 NULL 是比较好的选择，比某个神奇的常数要好。

MySQL 会在索引中存储 NULL 值，Oracle 不会。

## 范式和反范式

完全范式化和完全反范式化一般只存在与实验室中。

在范式化的数据库中，每个事实数据出现并只出现一次。

在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

### 范式的优点和缺点

在写密集的场景下做数据库性能优化时，一般会建议对数据库进行范式化。范式化有如下一些好处：

* 范世化的更新操作通常要比反范式化要快
* 当数据较好的范世化时，就只有很少或者没有重复数据，所以写入时要修改的数据会减少。
* 范式化表通常更小，能放在内存中，执行操作时会更快。
* 很少的冗余数据意味着检索列表数据时，DISTINCT 或 GROUP BY 语句使用的频率较低。

范式化的缺点是经常需要关联。稍微复杂一些的查询语句在符合范式的数据库上都可能需要至少一次关联或者更多。这会使查询代价昂贵，也可能导致一些索引策略失效。

### 反范式的优点和缺点

在反范式化的数据库中，所有的数据都在一张表中，可以很好的避免关联。

全表扫描基本上是顺序 I/O，但也不是全部都是，这与存储引擎的实现有关。

单独的表也能使用更有效的索引策略。

### 混用范式化和反范式化

实际应用中经常出现这种设计。

最常见的反范式化数据的方法是复制或者存储，在不同的表中存储相同的特定列。可以使用触发器更新缓存值，这使得实现这样的方案变得简单。

反范式化会使查询变得简单，但会使插入和更新的代价变高，因为可能会需要同时更新两张表。这就要考虑更新的频率和更新的时长，并和 SELECT 语句的使用频率做对比，选出一个折中的方案。

另外，从父表冗余一些数据到子表，可以加快某些类型的排序。

还可以在表中缓存一些衍生值，方便某些统计类的查询。

## 缓存表和汇总表

在同一张表中保存冗余的衍生数据可以提升性能。有时，也需要建立一张完全独立的汇总表或缓存表。

一般使用缓存表存储逻辑上的冗余数据。

使用汇总表存储使用 GROUP BY 聚合的数据。

汇总表可以降低一些统计类查询的代价。

缓存表对于优化搜索和检索查询语句很有效。

在使用汇总表和缓存表时，必须要决定是实时维护表格还是定期重建表格。这依赖于应用程序。

定期重建可以节省资源，保持表不会有很多碎片，以及有完全顺序组织的索引。

当重建缓存表和汇总表时，通常需要保证数据在操作时依然可用，这可以通过使用影子表来实现。

影子表指的是一张与旧真实表相同的表，在真实表重建时，可以在影子表上查询。重建完成后，可以通过一个原子的重命名操作切换影子表和原表。

例如，重建 my_summary 表，可以先创建 my_summary_new，然后填充好数据，最后和 my_summary 表切换。

```SQL
DROP TABLE IF EXISTS my_summary_new, my_summary_old;
CREATE TABLE my_summary_new LIKE my_summary;
... 填充 my_summary_new
RENAME TABLE my_summary TO my_summary_old, my_summary_new TO my_summary;
```

## 物化视图


物化视图实际是预先计算并存储在磁盘上的表。

MySQL 没有原生支持物化视图，但是可以使用开源工具 Flexviews 或者自己实现物化视图。

Flexviews 通过提取对原表的更改，可以增量的重新计算物化视图的内容。这意味这不需要通过查询原始数据就可以更新视图。

Flexviews 通过变更数据抓取功能，读取服务器的二进制日志并解析相关行的变更。

计算增量数据要比从原表中查询的效率高得多。

可以用基于物化视图的简单查询代替原来的复杂查询。

## 计数器表

如果直接在表中保存计数器，则在更新计数器时可能碰到并发问题。

创建一张独立的表存储计数器通常是好主意，这样可以使计数器表小且快。

使用独立的表可以帮助避免查询缓存失败。

比如，使用一个计数器表记录一个网站的点击次数。该表如下，只有一行数据。

```SQL
CREATE TABLE hit_counter(
	cnt int unsigned not null
) ENGINE=InnoDB;
UPDATE hit_counter SET cnt = cnt + 1; # 更新操作
```

则对于任何一个想要更新该表的事务来说，这条记录上都会有一个全局的互斥锁。这会导致这些事务只能串行执行，严重影响性能。

要获得更高的并发性能，可以将计数器保存在多行中，每次随机选择一行进行更新。计数器表如下：

```sql
CREATE TABLE hit_counter(
	slot tinyint unsigned not null primary key,
    cnt int unsigned not null
) ENGINE=InnoDB;
UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND() * 100; # 更新操作
SELECT SUM(cnt) FORM hit_counter; # 使用聚合查询获得统计结果
```

一个常见的需求是每个一段时间开始一个新的计数器，比如，每天开始一个。可以如下创建表：

```sql
CREATE TABLE day_hit_counter(
	day DATE NOT NULL,
    slot tinyint unsigned not null,
    cnt int unsigned not null,
    primary key(day,slot)
) ENGINE=InnoDB;
INSERT INTO day_hit_counter (day,slot,cnt)
VALUES (CURRENT_DATE,RAND() * 100,1)
ON DUPLICATE KEY UPDATE cnt = cnt + 1; # 更新语句
```



> INSERT ON DUPLICATE KEY UPDATE 语句
>
> 一般情况，当新插入的行的主键或者标记为 UNIQUE 的列的值与表中现有的行出现重复，MySQL 会返回一个 ERROR
>
> 但是，当使用  INSERT 语句的 ON DUPLICATE KEY UPDATE 选项时，MySQL 则会更新现有的行。
>
> 基本语法如下
>
> ```SQL 
> INSERT INTO table_name (column_list)
> VALUES (value_list)
> ON DUPLICATE KEY UPDATE
> 	c1=v1,
> 	c2=v2,
> 	...;
> ```
>
> 以上语句首先尝试向表中插入一行新数据。如果发生了 主键重复错误，那么该语句会使用 ON DUPLICATE KEY UPDATE 子句给出的键值对的值更新表中已有的行。

